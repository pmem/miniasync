---
layout: manual
Content-Style: 'text/css'
title: _MP(MINIASYNC_VDM, 3)
collection: miniasync
header: MINIASYNC_VDM
secondary_title: miniasync
...

[comment]: <> (SPDX-License-Identifier: BSD-3-Clause)
[comment]: <> (Copyright 2021, Intel Corporation)

[comment]: <> (miniasync_vdm.3 -- man page for miniasync vdm API)

[NAME](#name)<br />
[SYNOPSIS](#synopsis)<br />
[DESCRIPTION](#description)<br />
[ERRORS](#errors)<br />
[SEE ALSO](#see-also)<br />


# NAME #

**miniasync_vdm** - Virtual data mover API for miniasync library


# SYNOPSIS #

```c
#include <libminiasync.h>

struct vdm_descriptor *vdm_descriptor_synchronous(void);
struct vdm_descriptor *vdm_descriptor_pthreads(void);

struct vdm *vdm_new(struct vdm_descriptor *descriptor);
void vdm_delete(struct vdm *vdm);
```

For general description of miniasync see **miniasync**(7).


# DESCRIPTION #

XXX: add description here.

`struct vdm_descriptor *vdm_descriptor_synchronous(void);`

:	XXX add description here.

`struct vdm_descriptor *vdm_descriptor_threads(void);`

:   In order to use parallel memcpy on os threads, create an appropriate
descriptor:
```c
struct vdm_descriptor *vdm_async_descriptor = vdm_descriptor_threads();
```
Then, create a new virtual data mover instance using this descriptor:
```c
struct vdm *vdm = vdm_new(vdm_async_descriptor);
```
The next step is creating a future that will handle the memcpy operation:
```c
struct vdm_memcpy_future fut = vdm_memcpy(vdm, dst, src, size, flags);
```
Now, during `runtime_wait` or `runtime_wait_complete` this future will be polled
as long as it is not complete i.e. its state is not `FUTURE_STATE_COMPLETE`. 
When this kind of future is polled and it is in state `FUTURE_STATE_IDLE`, 
it tries to add its memcpy data into a buffer 
that is watched by worker threads. If the memcpy data were added to the buffer
successfully, the state of the future is set to `FUTURE_STATE_RUNNING`, because
we have a guarantee that some worker thread will perform this memcpy. Otherwise,
the state is set to `FUTURE_STATE_IDLE` and whole process is repeated again in a
next poll of this future. Polling a future in state `FUTURE_STATE_RUNNING` is just
a check if it's complete, so if it is - its state is set to `FUTURE_STATE_COMPLETE`,
otherwise it is still `FUTURE_STATE_RUNNING`. Worker threads perform memcpy
operations based on the data they receive from the buffer regarding FIFO policy.

`struct vdm *vdm_new(struct vdm_descriptor *descriptor);`

:	XXX add description here.

`void vdm_delete(struct vdm *vdm);`

:	XXX add description here.


## ERRORS ##

XXX add description here.


# SEE ALSO #

**miniasync**(7), **miniasync_future**(3), **miniasync_runtime**(3) and **<https://pmem.io>**
