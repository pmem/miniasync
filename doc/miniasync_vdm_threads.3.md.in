---
layout: manual
Content-Style: 'text/css'
title: _MP(MINIASYNC_VDM_THREADS, 3)
collection: miniasync
header: MINIASYNC_VDM_THREADS
secondary_title: miniasync
...

[comment]: <> (SPDX-License-Identifier: BSD-3-Clause)
[comment]: <> (Copyright 2022, Intel Corporation)

[comment]: <> (miniasync_vdm_threads.3 -- man page for miniasync vdm threads mover API)

[NAME](#name)<br />
[SYNOPSIS](#synopsis)<br />
[DESCRIPTION](#description)<br />
[RETURN VALUE](#return-value)<br />
[SEE ALSO](#see-also)<br />


# NAME #

**miniasync_vdm_threads** - Virtual data mover for miniasync using system threads


# SYNOPSIS #

```c
#include <libminiasync.h>

struct vdm_descriptor *vdm_descriptor_threads(void);
struct vdm_descriptor *vdm_descriptor_threads_polled(void);
```

For general description of miniasync see **miniasync**(7).


# DESCRIPTION #

In order to use parallel memcpy on system threads, create an appropriate
descriptor:
```c
struct vdm_descriptor *vdm_async_descriptor = vdm_descriptor_threads();
```
Then, create a new virtual data mover instance using this descriptor:
```c
struct vdm *vdm = vdm_new(vdm_async_descriptor);
```
The next step is creating a future that will handle the memcpy operation:
```c
struct vdm_memcpy_future fut = vdm_memcpy(vdm, dst, src, size, flags);
```
Now, during **runtime_wait**(3) or **runtime_wait_multiple**(3) this future will be polled
as long as it is not complete i.e. its state is not `FUTURE_STATE_COMPLETE`.
When this kind of future is polled and it is in state `FUTURE_STATE_IDLE`,
it tries to add its memcpy data into a queue of pending operations
that is watched by worker threads. If the memcpy data was added to the queue
successfully, the state of the future is set to `FUTURE_STATE_RUNNING`,
which guarantees that a worker thread will perform this operation. Otherwise,
the state is set to `FUTURE_STATE_IDLE` and whole process is repeated in a
next poll of this future. Polling a future in state `FUTURE_STATE_RUNNING` is just
a check if it's complete, so if it is - its state is set to `FUTURE_STATE_COMPLETE`,
otherwise it is still `FUTURE_STATE_RUNNING`. Memcpy operations are processed in
order in which they are put into the queue, but we cannot guarantee that they will
be processed in the same order as they are in the array of futures passed to
**runtime_wait_multiple**(3) if the count of operations is bigger than size of the queue.

```c
struct vdm_descriptor *vdm_async_descriptor = vdm_descriptor_threads_polled();
```
:   XXX add description for vdm_descriptor_threads_polled

# RETURN VALUE #

The **vdm_descriptor_threads** returns a pointer to `struct vdm_descriptor`
describing virtual data mover using system threads.

# SEE ALSO #

**miniasync**(7), **miniasync_future**(3), **miniasync_runtime**(3), **miniasync_vdm**(3), **runtime_wait**(3),
**runtime_wait_multiple**(3), **vdm_memcpy**(3), **vdm_new**(3) and **<https://pmem.io>**
